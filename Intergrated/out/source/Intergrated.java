/* autogenerated by Processing revision 1286 on 2022-10-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Intergrated extends PApplet {



PApplet myClass = this;

// Stacking Tower of Babel
boolean isTextureMode = false;
Tower tower = new Tower();

Character slave;
Block block;

// Demolishing Powers

NewLightnings lightnings; // 01. Lightnings
FireParticleSystem fire; // 02. Fire
ExplosionParticleSystem explosion; // 03. Explosion

// 4. Punch
boolean punchAct = false;
// 5. Chopsticks
boolean chopstickAct = false;
// 6. Wind
boolean balloonAttached =false;
boolean balloonAct = false;

// 22.10.18 : GameOver
GameOver gameOver; 

// 22.10.19 : Change the difficulty
float startTime;
float EachLevelPeriod;

// 22.10.20 : Background Image
PImage background;

// 22.10.21 : Music & Effets
SoundManager soundManager;

// 22.10.21 : WeatherAPI
WeatherAPI weatherAPI;

// 22.10.21 : Button UI
DemolishUI demolishUI;

 public void setup() {
    /* size commented out by preprocessor */;
    // size(1000, 1000, P3D);

    // 22.10.20 : Background Image
    background = loadImage("Background.png");
    
    // Stacking Tower
    slave = new Character(2);
    // 22.10.20 : texture - block
    isTextureMode = true;


    // Demolising Powers 1
    lightnings = new NewLightnings();
    fire = new FireParticleSystem(0, new PVector(width/2, height/2));
    explosion = new ExplosionParticleSystem(new PVector(mouseX, mouseY));


    // Demolising Powers 2

    // Punch
    windowBreak = loadImage("pngwing.com.png");//thanks for pngwing
    punchM = loadImage("pngaaa.com-76920.png");//thanks for pngaaa

    // Chopsticks
    chopstick = loadImage("chopstick.png");//thanks fo dlf.pt.

    // Wind
    balloon = loadImage("balloon.png"); // image thanks for flaticon


    // 22.10.18 : GameOver
    gameOver = new GameOver();

    // 22.10.19 : Change Difficulty
    startTime = millis();
    EachLevelPeriod = 10000;

    // 22.10.20 : Music & Effects
    soundManager = new SoundManager();
    
    // 22.10.21 : Weather API
    weatherAPI = new WeatherAPI();

    // 22.10.21 : Demolish UI & Button
    demolishUI = new DemolishUI(width/2, height/2);
}

 public void draw () {
    background(0xff, 0xff, 0xff);
    imageMode(CORNER);
    image(background, 0, 0, width, height);
    
    // Stacking Tower
    if (block != null) {
      block.createBlock();
      println(block.x + "    " + block.y);
    }

    slave.drawBlock(tower);
    tower.drawTower();
    slave.drawChar();
    
    
    // Demolising Powers 1
    lightnings.Update();
    fire.run();
    explosion.run();


    // Demolising Powers 2

    // Punch
    if (punchAct == true) {//function start
        Punching(block);

        if (block != null)
            block.y -=10;
    }

    // Chopsticks
    if(chopstickAct == true){
        Chopstick(block);
    }

    // Wind
    if (balloonAttached == true) {//check to activate function
        wind(block);
    } else if(balloonAct == true) {//check  
        beforeWind(block);
    }

    // 22.10.18 : Game Over
    gameOver.run();

    // 22.10.19 : Change the Difficulty
    if (millis() - startTime > EachLevelPeriod)  {
        startTime += EachLevelPeriod;
        slave.speed += 1;
    }
    
    // 22.10.21 : WeatherAPI
    weatherAPI.run();

    // 22.10.21 : Demolish UI
    demolishUI.drawPanel();
}


 public void BlockRemove () {
    block = null;
}


// Initial version of integration
 public void mousePressed () {
    
    for (int i = 0 ; i < DemolishUI.buttonPanel.size() ; i++) {
        DemolishUI.buttonPanel.get(i).buttonClicked(); // 여기부터 합시다!
    }

    /*
    // Checking highest stack block
    if (!tower.Tower.isEmpty()) {
        if (block != null && (punchAct || balloonAttached || chopstickAct)) {
            punchAct = false;
            balloonAttached = false;
            chopstickAct = false;

            BlockRemove();
        }

        block = tower.popBlock();

        if (key == '1')
            lightnings.ResetLightnings();
        else if (key == '2') {
            fire.startOfFireParticle(new PVector(block.x, block.y));
        } else if (key == '3') {
            explosion = new ExplosionParticleSystem(new PVector(block.x, block.y));
            explosion.startOfExplosion();
        } else if (key == '4') 
            punchAct = true;
        else if (key == '5')
            chopstickAct = true;
        else if (balloonAct) {
            if (balloonAct && (mouseX > block.x - block.size*10&&mouseX < block.x + block.size*10 && mouseY < block.y && mouseY > block.y - block.size * block.blockHeight)) {
                balloonAttached = true;
                balloonAct = false;
            }
        }
    } */
}

 public void keyPressed() {
    if (key == '6')
        balloonAct =true;
}
class Block {
  float x, y, size;
  int blockColor;
  float blockWidth, blockHeight;
  PImage img;

  boolean isTextureMode;

  // Default Constructor
  Block() { }

  // Constructor to get Block Location
  Block(float _x, float _y) {
    x = _x; y = _y;
    size = width / 384;
  }

  // Using COLOR
  Block(float _x, float _y, int _color) {
    x = _x; y = _y;
    size = width / 384;
    blockColor = _color;
    blockWidth = size * 40; blockHeight = size * 10;
    isTextureMode = false;

    x = x + size * 80;
    y = y + size * 60;
  }

  // Using TEXTURE(PImage)
  Block(float _x, float _y, PImage _img) {
    x = _x; y = _y;
    size = width / 384;
    img = _img;
    blockWidth = size * 40; blockHeight = size * 10;
    isTextureMode = true;

    x = x + size * 80;
    y = y + size * 60;
  }

   public void createBlock() {
    
    pushMatrix();
    
    if (isTextureMode) {
      drawTextureBlock();
    }
    else {
      drawColorBlock();
    }

    popMatrix();
  }

   public void drawTextureBlock() {
    noStroke();
    blockWidth = size * 40; blockHeight = size * 10;
    
    pushMatrix();
    
    translate(x, y);
    scale(map(y, height, 0, 3, 1), 1); 

    textureMode(NORMAL);
    beginShape();
    texture(img);
    vertex(- blockWidth/2,              - blockHeight/2,  0, 0);
    vertex(+ blockWidth/2,              - blockHeight/2,  1, 0);
    vertex(+ blockWidth/2,              + blockHeight/2,  1, 1);
    vertex(- blockWidth/2,              + blockHeight/2,  0, 1);
    endShape();

    popMatrix();
    
    return;
  }

   public void drawColorBlock() {
    noStroke();
    fill(blockColor);

    blockWidth = size * 40; blockHeight = size * 10;

    // DEFAULT BLOCK LOCATION
    beginShape();
    vertex(x - blockWidth/2,              y - blockHeight/2,  0, 0);
    vertex(x + blockWidth/2,              y - blockHeight/2,  0, 0);
    vertex(x + blockWidth/2,              y + blockHeight/2,  0, 0);
    vertex(x - blockWidth/2,              y + blockHeight/2,  0, 0);
    endShape(CLOSE);
    
    return;
  }

   public PVector getBlockCenter() {
    return new PVector(x, y);
  }
}
class Button {
  float x, y, size;
  int buttonColor;
  PImage img;
  String str;

  Button(float _x, float _y, PImage _img, String _str) {
    x = _x; y = _y;
    size = width / 384;
    img = _img;
    str = _str;
  }

   public void buttonClicked() {
    if (isButtonClicked() && !tower.Tower.isEmpty()) {
      // Get the block (Top of the Tower)
      Block topBlock = tower.Tower.get(tower.Tower.size() - 1);
      // When FIRE Button Clicked
      if (str.equals("Fire")) {
        fire.startOfFireParticle(topBlock.getBlockCenter());
      }
      // When BOMB Button Clicked
      if (str.equals("Bomb")) {
        explosion = new ExplosionParticleSystem(topBlock.getBlockCenter());
        explosion.startOfExplosion();
      }
      // When LIGHTNING Button Clicked
      // There are some PROBLEMS (CHANGING STROKE of UI)
      if (str.equals("Lightning")) {
        lightnings.ResetLightnings();
      }
      // When PUNCH Button Clicked
      if (str.equals("Punch")) {
        punchAct = true;
      }
      // When WIND Button Clicked
      if (str.equals("Wind")) {
        balloonAct = true;
      }
      // When CHOPSTICK Button Clicked
      if (str.equals("ChopStick")) {
        chopstickAct = true;
      }
      // DIDN'T add CHOPSTICK IMAGE for DEMOLISHING yet
    }
  }

  /**
    * NEW FUNCTION for BUTTON
    * 
    * returns TRUE of FALSE
    * When Button Clicked, returns TRUE
    * else, returns FALSE
  **/
   public boolean isButtonClicked() {
    return (mouseX >= x - size * 15 && mouseX <= x + size * 15 &&
            mouseY >= y - size * 15 && mouseY <= y + size * 15);
  }
}
class Character {
  // PNGs for Character
  ArrayList<PImage> slave = new ArrayList<>();
  ArrayList<PImage> slaveInvert = new ArrayList<>();
  PImage currentSprite;

  // For Character Location
  Block blockLoc = new Block(width / 2, height / 2);
  float startX = blockLoc.x + blockLoc.size * 60;
  float startY = blockLoc.y + blockLoc.size * 70;
  float x, y;

  // For Animation
  float seconds = 0.1f;
  float timeAdder = seconds;
  
  boolean isLeft = true;
  int i = 0;
  int speed;
  
  // Block Image
  ArrayList<PImage> BlockImages;
  
  Character(int _speed) {
    // Initializing 
    
    slave.add(loadImage("char1.png"));
    slave.add(loadImage("char2.png"));
    slave.add(loadImage("char3.png"));
    slave.add(loadImage("char4.png"));
    slave.add(loadImage("char5.png"));

    slaveInvert.add(loadImage("char1-invert.png"));
    slaveInvert.add(loadImage("char2-invert.png"));
    slaveInvert.add(loadImage("char3-invert.png"));
    slaveInvert.add(loadImage("char4-invert.png"));
    slaveInvert.add(loadImage("char5-invert.png"));

    x = startX; y = startY;
    speed = _speed;
    
    BlockImages = new ArrayList<PImage>();
    for (int i = 1 ; i <= 5; i ++) {
        BlockImages.add(loadImage("Block" + i + ".png"));
    }
  }

   public void drawChar() {
    pushMatrix();
    
    translate(x, y);
    imageMode(CENTER);
    
    changeChar();

    if (isLeft) {
      image(currentSprite, 0, 0);
    }
    else {
      image(currentSprite, 0, 0);
    }

    moveChar();
    
    popMatrix();
  }

   public void moveChar() {
    if (isLeft) {
      x -= blockLoc.size * speed;
    }
    else {
      x += blockLoc.size * speed;
    }

    if (x <= 0) {
      isLeft = false;
    }
    else if (x >= startX) {
      isLeft = true;
    }
  }

   public void changeChar() {
    // When the char turns
    if (isLeft) {
      currentSprite = slave.get(i);
    }
    else {
      currentSprite = slaveInvert.get(i);
    }

    if (millis() >= seconds * 1000) {
      seconds += timeAdder;
      if (++i >= 5) {
        i = 0;
      }

      if (isLeft) {
        currentSprite = slave.get(i);
      }
      else {
        currentSprite = slaveInvert.get(i);
      }
    }
  }

   public void drawBlock(Tower tower) {
    if (x >= startX) {
      if (isTextureMode) {
        tower.pushBlock(new Block(width / 2, height / 2, BlockImages.get((int)random(1, BlockImages.size())))); 
      }
      else {
        tower.pushBlock(new Block(width / 2, height / 2, color(random(255), random(255), random(255))));
      }
    }
  }
}
class DemolishUI {
  ArrayList<Button> buttonPanel = new ArrayList<>();
  float x, y;
  float startX;
  float size = width / 384;

  /**
   * *  ORDER OF BUTTONS
   * 1. FIRE
   * 2. BOMB
   * 3. LIGHTNING
   * 4. PUNCH
   * 5. WIND
   * 6. CHOPSTICK
   */
  DemolishUI(float _x, float _y) {
    x = _x - size * 80; y = _y - size * 90;
    startX = x;

    // DIRTY CODE... Will Fix it Later
    buttonPanel.add(new Button(x, y, loadImage("fire.png"), "Fire"));
    x += size * 30;
    buttonPanel.add(new Button(x, y, loadImage("bomb.png"), "Bomb"));
    x += size * 30;
    buttonPanel.add(new Button(x, y, loadImage("lightning.png"), "Lightning"));
    x += size * 30;
    buttonPanel.add(new Button(x, y, loadImage("punch.png"), "Punch"));
    x += size * 30;
    buttonPanel.add(new Button(x, y, loadImage("wind.png"), "Wind"));
    x += size * 30;
    buttonPanel.add(new Button(x, y, loadImage("chopstickUI.png"), "Chopstick"));
  }

   public void drawPanel() {
    rectMode(CENTER);
    strokeWeight(4);
    imageMode(CENTER);
    for (int i = 0; i < buttonPanel.size(); i++, x += size * 30) {
      fill(255);
      stroke(0x00, 0x00, 0x00);
      square(x, y, size * 30);
      image(buttonPanel.get(i).img, x, y, size * 20, size * 20);
    }
    strokeWeight(0);
    
    x = startX;

    rectMode(CORNER);
  }
}
class ExplosionParticle {
  PVector position;
  PVector velocity;
  PVector acceleration;
  float lifespan;

  PImage img;
  float Bigsize = 3;

  ExplosionParticle(PVector l, PImage img_) {
    acceleration = new PVector(random(-0.05f, 0.05f), random(-0.05f, 0.05f));
    velocity = new PVector(random(-1, 1), random(-1, 1));
    position = l.copy();
    lifespan = 255.0f;

    img = img_;
  }

   public void run() {
    pushMatrix();
    
    translate(position.x, position.y);
    scale(Bigsize / 10);  
    update();
    display();
    Bigsize -= Bigsize/50;

    popMatrix();
  }

  // Method to update position
   public void update() {
    velocity.add(acceleration);
    position.add(velocity);
    lifespan -= 1.0f;
  }

  // Method to display
   public void display() {
   
    tint(255, lifespan);
    image(img, 0, 0);
    tint(255, 255);
    /* draw 
    stroke(255, random(0,100), 0, lifespan);
    fill(255, random(0,100), 0, lifespan);
    ellipse(position.x, position.y, 8, 8);
    */
  }

  // Is the particle still useful?
   public boolean isDead() {
    if (lifespan < 0.0f) {
      return true;
    } else {
      return false;
    }
  }
}
// A class to describe a group of Particles
// An ArrayList is used to manage the list of Particles 

class ExplosionParticleSystem {
  ArrayList<ExplosionParticle> particles;
  PVector origin;

  PImage img;

  int origianlDuringTime = 2000;
  float elapsedTime = millis();
  float endTime = 0;

  // Check Running
  boolean isRunning = false; 

  ExplosionParticleSystem(PVector position) {
    origin = position.copy();
    particles = new ArrayList<ExplosionParticle>();

    img = loadImage("explosion.png");
  }

   public void addParticle() {
    particles.add(new ExplosionParticle(origin, img));
  }

   public void run() {
    elapsedTime = millis();

    if (elapsedTime < endTime) {
      for (int i = 0 ; i < 3 ; i++)
        addParticle();
    } else if (isRunning) {
      isRunning = false;

      // signal
      BlockRemove();
    }

    for (int i = particles.size()-1; i >= 0; i--) {
      ExplosionParticle p = particles.get(i);
      p.run();
      if (p.isDead()) {
        particles.remove(i);
      }
    }
  }

   public void startOfExplosion () {
      if (endTime < millis()) {
        endTime = millis() + origianlDuringTime;

        isRunning = true;
      }
  }

}
class FireParticle {
    // For Move Particle
    PVector location;
    PVector velocity;
    PVector acceleration;

    float lifespan;

    // for scale
    float FireHeight = height/10;

    PImage img;

    FireParticle(PVector loc) {
        acceleration = new PVector(0, 0);

        float vx = randomGaussian()*0.3f;
        float vy = randomGaussian()*0.3f - 1.0f;
        velocity = new PVector(vx, vy);
        
        location = loc.copy();
        
        lifespan = 100.0f;
    }

    FireParticle(PVector loc, PImage img_) {
        acceleration = new PVector(0, 0);

        float vx = randomGaussian() * width / 1080;
        float vy = (randomGaussian() - 5.0f) * width / 1080;
        velocity = new PVector(vx, vy);
        
        location = loc.copy();
        
        lifespan = 150.0f;
        
        img = img_;
    }

     public void run() {
        pushMatrix();
        
        update();
        
        render();
        
        popMatrix();
    }

    // scattering fireworks expression
     public void applyForce(PVector f) {
        acceleration.add(f);
    }  

    // Method to update position
     public void update() {
        velocity.add(acceleration);
        location.add(velocity);
        lifespan -= 2.5f;
        
        acceleration.mult(0); // clear Acceleration
    }

    // Method to display
     public void render() {
        // Image Version
        pushMatrix();
        
        translate(location.x, location.y);
        scale(0.3f);
        imageMode(CENTER);
        
        // Make Black and tranparent
        float toBlack = map(lifespan, 0, 150, 0, 255);
        tint(toBlack, lifespan);
        image(img, 0, 0);
        
        popMatrix();
        tint(255, 255);
        /*// Drawing a circle instead
        fill(255,0,0, lifespan);
        noStroke();
        ellipse(location.x,location.y, FireHeight, FireHeight);*/
    }

    // Is the particle still useful?
     public boolean isDead() {
        if (lifespan <= 0.0f) {
            return true;
        } else {
            return false;
        }
    }
}
class FireParticleSystem {

    ArrayList<FireParticle> fireParticles;    // An arraylist for all the fireParticles
    PVector origin;                   // An origin point for where fireParticles are birthed
    PImage img;

    int origianlDuringTime = 2;
    float elapsedTime = millis();
    float endTime = 0;

    boolean isRunning;

    FireParticleSystem(int num, PVector blockLocation) {
        // Initializing
        fireParticles = new ArrayList<FireParticle>();              
        origin = blockLocation.copy();                                   // Store the origin point
        img = loadImage("flame.png");
        
        // making Particles
        for (int i = 0; i < num; i++) {
        fireParticles.add(new FireParticle(origin));         
        }

        isRunning = false;
    }

    FireParticleSystem(int num, PVector blockLocation, PImage img_) {
        // Initializing
        fireParticles = new ArrayList<FireParticle>();
        origin = blockLocation.copy();                                   
        img = img_;

        for (int i = 0; i < num; i++) {
        fireParticles.add(new FireParticle(origin, img));         // Add "num" amount of fireParticles to the arraylist
        }

        isRunning = false;
    }

    // play all particles
     public void run() {
        elapsedTime = millis();

        for (int i = fireParticles.size()-1; i >= 0; i--) {
            FireParticle p = fireParticles.get(i);
            p.run();

            if (p.isDead()) {
                fireParticles.remove(i);
            }
        }

        if (elapsedTime < endTime) {
            for (int i = 0 ; i < 2 ; i++)
                addParticle();
        } else if (isRunning) {
            isRunning = false;

            // signal
            BlockRemove();
        }
    }

    // Method to add a force vector to all fireParticles currently in the system
     public void applyForce(PVector dir) {
        for (FireParticle p : fireParticles) {
            p.applyForce(dir);
        }
    }  

         public void applyForce() {
        for (FireParticle p : fireParticles) {
            p.applyForce(new PVector(0.1f, 0));
        }
    }  

     public void addParticle() {
        fireParticles.add(new FireParticle(origin, img));
    }

     public void startOfFireParticle () {
        if (endTime < millis()) {
            endTime = millis() + 2000;
            isRunning = true;
        }
    }

     public void startOfFireParticle (PVector blockPosition) {
        if (endTime < millis()) 
        {
            origin = blockPosition;
            endTime = millis() + 2000;
            isRunning = true;
        }
    }
}
// Processing PDE files are designed by inner class (inference)
// tower.Tower.peek can also conneted in other class like in here

class GameOver {
    boolean IsGameOver = false;
    boolean firstStart = true;
    // Font
    PFont font1;
    String gameOverMessage = "Game Over!";
    float lineHeight;
    

     public void GameOverCheck () {
        if (!tower.Tower.isEmpty()) {
            if (tower.Tower.peek().y < tower.Tower.peek().blockHeight * 2)
                IsGameOver = true;
        }
    }

     public void run () {
        if (firstStart) {
            firstStart = false;

            lineHeight = tower.Tower.peek().blockHeight;
            font1 = createFont("Arial", 16);
        }

        GameOverCheck();

        if (IsGameOver) GameOverDraw(); 
        else GameOverLineDraw();
        
    }

     public void GameOverDraw () {
        background(0xff, 0xff, 0xff);

        pushMatrix();
        
        translate(width/2, height/2, 0);
        textFont(font1, height/20);
        textAlign(CENTER);
        text(gameOverMessage, 0, 0);

        popMatrix();
    }

     public void GameOverLineDraw () {
        stroke(255, 0, 0);
        fill(255, 0, 0);
        rect(0, lineHeight, width, 10);
    }
}
class NewLightning {
    PVector start, end;
    
    // Lightning...
    float angleOfLine, currentProgress = 0;
    float originalDistance, limitDistance;
    float speed = width / 30;

    // Reculsion
    NewLightning s1, s2;
    boolean issplited = false;
    boolean bothSplited = false;

    // Reculsion end Condition
    int reculsionCount, max;
    boolean dead = false;


    NewLightning(PVector start, int reculsionCount, int max) {
        // Lightning
        
        this.start = start;

        angleOfLine = random(PI/4, 3 * PI/4);

        this.originalDistance = width/8;
        this.limitDistance = random(originalDistance/2) + originalDistance;
        
        end = new PVector(start.x + cos(angleOfLine) * this.limitDistance, start.y + sin(angleOfLine) * this.limitDistance);
        
        // For Reculsion
        this.reculsionCount = reculsionCount;
        this.max = max;
    }

     public void Update () {

        if(currentProgress < limitDistance) {
            currentProgress += speed;
        } else {
            // Only once when split
            if(!issplited && reculsionCount < max) {
                currentProgress = limitDistance;

                issplited = true;
                if(random(1) > 0.5f) {
                    bothSplited = true;
                    s1 = new NewLightning(end, reculsionCount + 1, max);
                    s2 = new NewLightning(end, reculsionCount + 1, max);
                }  else {
                    bothSplited = false;
                    s1 = new NewLightning(end, reculsionCount + 1, max);
                }
            }

            // After Splited
            if (reculsionCount < max) {
                s1.Update();
                if(bothSplited) {
                    s2.Update();
                }
            } 
            
            if(reculsionCount >= max) {
                dead = true;
            } else {
                if(bothSplited) dead = s1.dead && s2.dead;
                else dead = s1.dead;
            }
        }
    }

     public void show() {
    
        stroke(255, 255, 0);
        strokeWeight(currentProgress/limitDistance * width/200);
        
        line(start.x, start.y, start.x + cos(angleOfLine) * currentProgress, start.y + sin(angleOfLine) * currentProgress);
        
        if(issplited) {
            s1.show();
            
            if(bothSplited) {
                s2.show();
            }
        }

        strokeWeight(0);
    }
}
class NewLightnings {
    ArrayList<NewLightning> lightnings = new ArrayList<NewLightning>(); 
    boolean firstOccur = false;

    // Check Running
    boolean isRunning = false;

     public void Update () {
        if(firstOccur) {
            firstOccur = false;
            for (int i = 0 ; i < 7 ; i++)
                lightnings.add(new NewLightning(new PVector(random(0, width), 0), 0, 7));

            isRunning = true;
        }

        for (int i = lightnings.size() - 1; i >=0; i--) {
            lightnings.get(i).Update();
            lightnings.get(i).show();

            if (lightnings.get(i).dead) {
                lightnings.remove(i);
            }
        } 
        
        if (lightnings.size() == 0 && isRunning) {
            isRunning = false;

            // signal
            BlockRemove();
        }
    }

     public void ResetLightnings () {
        firstOccur = true;
    }

}


class SoundManager {
    // By using HashMap, How about soundFile call by that String?

    HashMap<String,SoundFile> soundCollection = new HashMap<String,SoundFile>();
    String[] soundNames = {"Soundsample.mp3",
                            
                            
                            };

    SoundManager () {
      // Please Put sounds to soundCollection
        for(String soundName : soundNames) {
            soundCollection.put(soundName, new SoundFile(myClass, soundName));
        }

        // soundCollection.get("Song.mp3").loop(); // (Background Music)
    }

     public void SoundPlay (String soundName) {
        soundCollection.get(soundName).play();
    }
}
class Tower {
  Stack<Block> Tower = new Stack<>();

  // DEFAULT Constructor
  Tower() {};

   public void drawTower() {
    for (int i = 0; i < Tower.size(); i++) {
      if (Tower.get(i).isTextureMode) {
        Tower.get(i).drawTextureBlock();
      }
      else {
        Tower.get(i).drawColorBlock();
      }
    }

    return;
  }

   public void pushBlock(Block block) {
    if (Tower.isEmpty()) {
      Tower.push(block);
    }
    else {
      block.y = Tower.peek().y - Tower.peek().blockHeight;
      Tower.push(block);
    }

    return;
  }

   public Block popBlock() {
    return Tower.pop();
  }
}
class WeatherAPI {
    // Weather
    String API_KEY = "4d54a1ec2d1746a823e46b9a79d59fde";
    String wurl = "https://api.openweathermap.org/data/2.5/weather?q=Suwon,kr&lat={lat}&lon={lon}&appid="+API_KEY;
    JSONObject weatherInfo;
    PImage weatherImage[] = new PImage[4]; // thanks for flaticon ()
    String tw;
    
    PFont font;
    
    // Time
    String turl = "http://worldtimeapi.org/api/timezone/Asia/Seoul";
    JSONObject tjson;
    String tt;


    WeatherAPI () {
        // Weather
        weatherInfo = loadJSONObject(wurl);
        font = createFont("h8514fix",height/12); // thanks for microsoft
        for(int i =0;i<4;i++){
            weatherImage[i] = loadImage("Weather"+i+".png");
        }

        tw = weatherInfo.getJSONArray("weather").getJSONObject(0).getString("icon");

        // Time
        tjson = loadJSONObject(turl);
        tt = tjson.getString("datetime");
        tt = tt.substring(tt.length() - 21, tt.length() - 16);
    }


    int s;
    boolean sCheck = false;

     public void run () {
        s = second();
        if (s == 0 && sCheck == false) {
            tjson = loadJSONObject(turl);
            tt = tjson.getString("datetime");
            tt = tt.substring(tt.length() - 21, tt.length() - 16);
            weatherInfo = loadJSONObject(wurl);
            tw = weatherInfo.getJSONArray("weather").getJSONObject(0).getString("icon");
            sCheck = true;
        } 

        if(s == 1) sCheck = false;

        textFont(font,height/12);
        fill(0);
        text(tt,width-height/4,height/12);
        
        if(tw =="09d" || tw == "09n" || tw == "10d" || tw == "10n"){
            image(weatherImage[2],width - height/4,height/6,height/8,height/8);
        }else if(tw == "11d" || tw =="11n"){
            image(weatherImage[3],width - height/4,height/6,height/8,height/8);
        }else if(tw == "50d" || tw == "50n"){
            image(weatherImage[0],width - height/5,height/7,height/8,height/8);
        }else{
            image(weatherImage[1],width - height/5,height/7,height/8,height/8);
        }
    }
}
PImage chopstick;
float t = 0;

 public void Chopstick(Block block) {
  Block block_ = block;
  t+=0.02f;
  float tx;
  float ty;

  if (t<1) {
    tx = lerp(width, block_.x*16/11, t);
    ty = lerp(0, block_.y - block_.size*block.blockHeight*5/2, t);
    pushMatrix();
    imageMode(CENTER);
    // block_.createBlock();
    image(chopstick, tx, ty, block_.size*block_.blockHeight*5, block_.size*block_.blockHeight*5);
    popMatrix();
  } else if (block_.y >0) {
    block_.y -=5;
    pushMatrix();
    imageMode(CENTER);
    // block_.createBlock();
    image(chopstick,block_.x*16/11,block_.y - block_.size*block.blockHeight*5/2,block_.size*block_.blockHeight*5, block_.size*block_.blockHeight*5);
    popMatrix();
  } else {
    chopstickAct = false;
    BlockRemove();
    t = 0;
  }
}
float punchTimeChecker = 0;
PImage windowBreak;
PImage punchM;

 public void Punching(Block block) {
  Block block_ = block;

  punchTimeChecker +=0.1f;
  if (punchTimeChecker < 1) {
    if (block != null) {
      pushMatrix();
      imageMode(CENTER);
      image(windowBreak, width/2, height/2, width, height);
      image(punchM, block_.x, height*3/4, width/3, height/2);
      popMatrix();
    }
  } 
  
  if (!(block_.size <= 0)) {
    block.size -= block.size/30;
  }
  
  if (block.y <= 0) {
      punchAct = false; //block go to outside of window finish the function
      BlockRemove();

      punchTimeChecker = 0;
  }
}
PImage balloon;
 public void beforeWind(Block block) { // if balloon function start balloon follow mouse
  pushMatrix();
  imageMode(CENTER);
  
  if (!tower.Tower.isEmpty())
    image(balloon, mouseX, mouseY, tower.Tower.peek().size*tower.Tower.peek().blockHeight, tower.Tower.peek().size*tower.Tower.peek().blockHeight);
  
  popMatrix();
}

 public void wind(Block block) { // balloon attached and fly away
  Block block_ = block;
  block_.x += 3;
  block_.y -=3;
  block_.createBlock();
  pushMatrix();
  imageMode(CENTER);
  image(balloon, block_.x, block_.y -block.blockHeight/2, block.size*block.blockHeight, block.size*block.blockHeight);
  popMatrix();
  if (block_.y<0) {
    balloonAttached = false; // finish the function
    BlockRemove();
  }
}


  public void settings() { size(displayWidth, displayHeight, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Intergrated" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}

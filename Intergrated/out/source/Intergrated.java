/* autogenerated by Processing revision 1286 on 2022-10-14 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Intergrated extends PApplet {




// Stacking Tower of Babel
boolean isTextureMode = false;
Tower tower = new Tower();

Character slave;
Block block;


// Demolishing Powers

NewLightnings lightnings; // 01. Lightnings
FireParticleSystem fire; // 02. Fire
ExplosionParticleSystem explosion; // 03. Explosion

// 4. Punch
boolean punchAct = false;
// 5. Chopsticks
boolean chopstickAct = false;
// 6. Wind
boolean balloonAttached =false;
boolean balloonAct = false;


 public void setup() {
    /* size commented out by preprocessor */;
    
    // Stacking Tower
    slave = new Character(2);


    // Demolising Powers 1
    lightnings = new NewLightnings();
    fire = new FireParticleSystem(0, new PVector(width/2, height/2));
    explosion = new ExplosionParticleSystem(new PVector(mouseX, mouseY));


    // Demolising Powers 2

    // Punch
    windowBreak = loadImage("pngwing.com.png");//thanks for pngwing
    punchM = loadImage("pngaaa.com-76920.png");//thanks for pngaaa

    // Chopsticks
    chopstick = loadImage("chopstick.png");//thanks fo dlf.pt.

    // Wind
    balloon = loadImage("balloon.png"); // image thanks for flaticon
}

 public void draw () {
    background(0xff, 0xff, 0xff);
    
    // Checking highest stack block
    if (!tower.Tower.isEmpty()) {
        block = tower.Tower.peek();
    }
    
    // Stacking Tower
    slave.drawBlock(tower);
    tower.drawTower();
    slave.drawChar();
    

    // Demolising Powers 1
    lightnings.Update();
    fire.run();
    explosion.run();


    // Demolising Powers 2

    // Punch
    if (punchAct == true) {//function start
        Punching(block);
        block.y -=10;
    }

    // Chopsticks
    if(chopstickAct == true){
        Chopstick(block);
    }

    // Wind
    if (balloonAttached == true) {//check to activate function
        wind(block);
    } else if(balloonAct == true) {//check  
        beforeWind(block);
    }

}


// Initial version of integration
 public void mousePressed () {
    if (key == '1')
        lightnings.ResetLightnings();
    else if (key == '2') {
        fire.startOfFireParticle(new PVector(block.x, block.y));
        println(block.x);
    } else if (key == '3') {
        explosion = new ExplosionParticleSystem(new PVector(block.x, block.y));
        explosion.stratOfExplosion();
    } else if (key == '4') 
        punchAct = true;
    else if (key == '5')
        chopstickAct = true;
    else if (key == '6') {
        if (balloonAct && (mouseX > block.x - block.size*10&&mouseX < block.x + block.size*10 && mouseY < block.y && mouseY > block.y - block.size * block.blockHeight)) {
            balloonAttached = true;
            balloonAct = false;
        }
    }
}

 public void keyPressed() {
    if (key == '6')
        balloonAct =true;
}
class Block {
  float x, y, size;
  int blockColor;
  float blockWidth, blockHeight;
  PImage img;

  boolean isTextureMode;

  // Default Constructor
  Block() { }

  // Constructor to get Block Location
  Block(float _x, float _y) {
    x = _x; y = _y;
    size = width / 384;
  }

  // Using COLOR
  Block(float _x, float _y, int _color) {
    x = _x; y = _y;
    size = width / 384;
    blockColor = _color;
    blockWidth = size * 40; blockHeight = size * 10;
    isTextureMode = false;
  }

  // Using TEXTURE(PImage)
  Block(float _x, float _y, PImage _img) {
    x = _x; y = _y;
    size = width / 384;
    img = _img;
    blockWidth = size * 40; blockHeight = size * 10;
    isTextureMode = true;
  }

   public void createBlock() {
    if (isTextureMode) {
      drawTextureBlock();
    }
    else {
      drawColorBlock();
    }
  }

   public void drawTextureBlock() {
    noStroke();
    
    textureMode(NORMAL);
    beginShape();
    texture(img);
    vertex(x + size * 80,              y + size * 60,                0, 0);
    vertex(x + size * 80 + blockWidth, y + size * 60,                1, 0);
    vertex(x + size * 80 + blockWidth, y + size * 60 + blockHeight,  1, 1);
    vertex(x + size * 80,              y + size * 60 + blockHeight,  0, 1);
    endShape();
    
    return;
  }

   public void drawColorBlock() {
    noStroke();
    fill(blockColor);

    // DEFAULT BLOCK LOCATION
    beginShape();
    vertex(x + size * 80,              y + size * 60,                0, 0);
    vertex(x + size * 80 + blockWidth, y + size * 60,                0, 0);
    vertex(x + size * 80 + blockWidth, y + size * 60 + blockHeight,  0, 0);
    vertex(x + size * 80,              y + size * 60 + blockHeight,  0, 0);
    endShape(CLOSE);
    
    return;
  }
}
class Character {
  // PNGs for Character
  ArrayList<PImage> slave = new ArrayList<>();
  ArrayList<PImage> slaveInvert = new ArrayList<>();
  PImage currentSprite;

  // For Character Location
  Block blockLoc = new Block(width / 2, height / 2);
  float startX = blockLoc.x + blockLoc.size * 60;
  float startY = blockLoc.y + blockLoc.size * 43;
  float x, y;

  // For Animation
  float seconds = 0.1f;
  float timeAdder = seconds;
  
  boolean isLeft = true;
  int i = 0;
  int speed;
  
  Character(int _speed) {
    slave.add(loadImage("char1.png"));
    slave.add(loadImage("char2.png"));
    slave.add(loadImage("char3.png"));
    slave.add(loadImage("char4.png"));
    slave.add(loadImage("char5.png"));

    slaveInvert.add(loadImage("char1-invert.png"));
    slaveInvert.add(loadImage("char2-invert.png"));
    slaveInvert.add(loadImage("char3-invert.png"));
    slaveInvert.add(loadImage("char4-invert.png"));
    slaveInvert.add(loadImage("char5-invert.png"));

    x = startX; y = startY;
    speed = _speed;
  }

   public void drawChar() {
    changeChar();

    if (isLeft) {
      image(currentSprite, x, y);
    }
    else {
      image(currentSprite, x, y);
    }

    moveChar();
  }

   public void moveChar() {
    if (isLeft) {
      x -= blockLoc.size * speed;
    }
    else {
      x += blockLoc.size * speed;
    }

    if (x <= 0) {
      isLeft = false;
    }
    else if (x >= startX) {
      isLeft = true;
    }
  }

   public void changeChar() {
    // When the char turns
    if (isLeft) {
      currentSprite = slave.get(i);
    }
    else {
      currentSprite = slaveInvert.get(i);
    }

    if (millis() >= seconds * 1000) {
      seconds += timeAdder;
      if (++i >= 5) {
        i = 0;
      }

      if (isLeft) {
        currentSprite = slave.get(i);
      }
      else {
        currentSprite = slaveInvert.get(i);
      }
    }
  }

   public void drawBlock(Tower tower) {
    if (x >= startX) {
      if (isTextureMode) {
        tower.pushBlock(new Block(width / 2, height / 2, loadImage("sunflower.jpg"))); // this is problem!!!!!! - Difference Between two of them.
      }
      else {
        tower.pushBlock(new Block(width / 2, height / 2, color(random(255), random(255), random(255))));
      }
    }
  }
}
class ExplosionParticle {
  PVector position;
  PVector velocity;
  PVector acceleration;
  float lifespan;

  PImage img;
  float Bigsize = 3;

  ExplosionParticle(PVector l, PImage img_) {
    acceleration = new PVector(random(-0.05f, 0.05f), random(-0.05f, 0.05f));
    velocity = new PVector(random(-1, 1), random(-1, 1));
    position = l.copy();
    lifespan = 255.0f;

    img = img_;
  }

   public void run() {
    pushMatrix();
    
    translate(position.x, position.y);
    scale(Bigsize / 10);  
    update();
    display();
    Bigsize -= Bigsize/50;

    popMatrix();
  }

  // Method to update position
   public void update() {
    velocity.add(acceleration);
    position.add(velocity);
    lifespan -= 1.0f;
  }

  // Method to display
   public void display() {
   
    tint(255, lifespan);
    image(img, 0, 0);
    
    /* draw 
    stroke(255, random(0,100), 0, lifespan);
    fill(255, random(0,100), 0, lifespan);
    ellipse(position.x, position.y, 8, 8);
    */
  }

  // Is the particle still useful?
   public boolean isDead() {
    if (lifespan < 0.0f) {
      return true;
    } else {
      return false;
    }
  }
}
// A class to describe a group of Particles
// An ArrayList is used to manage the list of Particles 

class ExplosionParticleSystem {
  ArrayList<ExplosionParticle> particles;
  PVector origin;

  PImage img;

  int origianlDuringTime = 2;
  int elapsedTime = second();
  int endTime = 0;

  ExplosionParticleSystem(PVector position) {
    origin = position.copy();
    particles = new ArrayList<ExplosionParticle>();

    img = loadImage("explosion.png");
  }

   public void addParticle() {
    particles.add(new ExplosionParticle(origin, img));
  }

   public void run() {
    elapsedTime = second();

    if (elapsedTime < endTime) {
      for (int i = 0 ; i < 3 ; i++)
        addParticle();
    }

    for (int i = particles.size()-1; i >= 0; i--) {
      ExplosionParticle p = particles.get(i);
      p.run();
      if (p.isDead()) {
        particles.remove(i);
      }
    }
  }

   public void stratOfExplosion () {
      endTime = second() + origianlDuringTime;
  }

}
class FireParticle {
    // For Move Particle
    PVector location;
    PVector velocity;
    PVector acceleration;

    float lifespan;

    // for scale
    float FireHeight = height/10;

    PImage img;

    FireParticle(PVector loc) {
        acceleration = new PVector(0, 0);

        float vx = randomGaussian()*0.3f;
        float vy = randomGaussian()*0.3f - 1.0f;
        velocity = new PVector(vx, vy);
        
        location = loc.copy();
        
        lifespan = 100.0f;
    }

    FireParticle(PVector loc, PImage img_) {
        acceleration = new PVector(0, 0);

        float vx = randomGaussian() * width / 1080;
        float vy = (randomGaussian() - 5.0f) * width / 1080;
        velocity = new PVector(vx, vy);
        
        location = loc.copy();
        
        lifespan = 150.0f;
        
        img = img_;
    }

     public void run() {
        
        update();
        
        render();
    }

    // scattering fireworks expression
     public void applyForce(PVector f) {
        acceleration.add(f);
    }  

    // Method to update position
     public void update() {
        velocity.add(acceleration);
        location.add(velocity);
        lifespan -= 2.5f;
        
        acceleration.mult(0); // clear Acceleration
    }

    // Method to display
     public void render() {
        // Image Version
        pushMatrix();
        
        translate(location.x, location.y);
        scale(0.3f);
        imageMode(CENTER);
        
        // Make Black and tranparent
        float toBlack = map(lifespan, 0, 150, 0, 255);
        tint(toBlack, lifespan);
        image(img, 0, 0);
        
        popMatrix();
        
        /*// Drawing a circle instead
        fill(255,0,0, lifespan);
        noStroke();
        ellipse(location.x,location.y, FireHeight, FireHeight);*/
    }

    // Is the particle still useful?
     public boolean isDead() {
        if (lifespan <= 0.0f) {
            return true;
        } else {
            return false;
        }
    }
}
class FireParticleSystem {

    ArrayList<FireParticle> fireParticles;    // An arraylist for all the fireParticles
    PVector origin;                   // An origin point for where fireParticles are birthed
    PImage img;

    int origianlDuringTime = 2;
    int elapsedTime = second();
    int endTime = 0;

    FireParticleSystem(int num, PVector blockLocation) {
        // Initializing
        fireParticles = new ArrayList<FireParticle>();              
        origin = blockLocation.copy();                                   // Store the origin point
        img = loadImage("flame.png");
        
        // making Particles
        for (int i = 0; i < num; i++) {
        fireParticles.add(new FireParticle(origin));         
        }
    }

    FireParticleSystem(int num, PVector blockLocation, PImage img_) {
        // Initializing
        fireParticles = new ArrayList<FireParticle>();
        origin = blockLocation.copy();                                   
        img = img_;

        for (int i = 0; i < num; i++) {
        fireParticles.add(new FireParticle(origin, img));         // Add "num" amount of fireParticles to the arraylist
        }
    }

    // play all particles
     public void run() {
        elapsedTime = second();

        
        for (int i = fireParticles.size()-1; i >= 0; i--) {
            FireParticle p = fireParticles.get(i);
            p.run();

            if (p.isDead()) {
                fireParticles.remove(i);
            }
        }

        if (elapsedTime < endTime) {
            for (int i = 0 ; i < 2 ; i++)
                addParticle();
        }
    }

    // Method to add a force vector to all fireParticles currently in the system
     public void applyForce(PVector dir) {
        for (FireParticle p : fireParticles) {
            p.applyForce(dir);
        }
    }  

         public void applyForce() {
        for (FireParticle p : fireParticles) {
            p.applyForce(new PVector(0.1f, 0));
        }
    }  

     public void addParticle() {
        fireParticles.add(new FireParticle(origin, img));
    }

     public void startOfFireParticle () {
        endTime = second() + origianlDuringTime;
    }

     public void startOfFireParticle (PVector blockPosition) {
        origin = blockPosition;
        endTime = second() + origianlDuringTime;
    }
}
class NewLightning {
    PVector start, end;
    
    // Lightning...
    float angleOfLine, currentProgress = 0;
    float originalDistance, limitDistance;
    float speed = width / 30;

    // Reculsion
    NewLightning s1, s2;
    boolean issplited = false;
    boolean bothSplited = false;

    // Reculsion end Condition
    int reculsionCount, max;
    boolean dead = false;


    NewLightning(PVector start, int reculsionCount, int max) {
        // Lightning
        
        this.start = start;

        angleOfLine = random(PI/4, 3 * PI/4);

        this.originalDistance = width/15;
        this.limitDistance = random(originalDistance/2) + originalDistance;
        
        end = new PVector(start.x + cos(angleOfLine) * this.limitDistance, start.y + sin(angleOfLine) * this.limitDistance);
        
        // For Reculsion
        this.reculsionCount = reculsionCount;
        this.max = max;
    }

     public void Update () {

        if(currentProgress < limitDistance) {
            currentProgress += speed;
        } else {
            // Only once when split
            if(!issplited && reculsionCount < max) {
                currentProgress = limitDistance;

                issplited = true;
                if(random(1) > 0.5f) {
                    bothSplited = true;
                    s1 = new NewLightning(end, reculsionCount + 1, max);
                    s2 = new NewLightning(end, reculsionCount + 1, max);
                }  else {
                    bothSplited = false;
                    s1 = new NewLightning(end, reculsionCount + 1, max);
                }
            }

            // After Splited
            if (reculsionCount < max) {
                s1.Update();
                if(bothSplited) {
                    s2.Update();
                }
            } 
            
            if(reculsionCount >= max) {
                dead = true;
            } else {
                if(bothSplited) dead = s1.dead && s2.dead;
                else dead = s1.dead;
            }
        }
    }

     public void show() {
    
        stroke(255, 255, 0);
        strokeWeight(currentProgress/limitDistance * width/200);
        
        line(start.x, start.y, start.x + cos(angleOfLine) * currentProgress, start.y + sin(angleOfLine) * currentProgress);
        
        if(issplited) {
            s1.show();
            
            if(bothSplited) {
                s2.show();
            }
        }
    }
}
class NewLightnings {
    ArrayList<NewLightning> lightnings = new ArrayList<NewLightning>(); 
    boolean firstOccur = true;

    // Check Done
    boolean Done = false;

     public void Update () {
        if(firstOccur) {
            firstOccur = false;
            for (int i = 0 ; i < 3 ; i++)
                lightnings.add(new NewLightning(new PVector(random(0, width), 0), 0, 7));
        }

        for (int i = lightnings.size() - 1; i >=0; i--) {
            lightnings.get(i).Update();
            lightnings.get(i).show();

            if (lightnings.get(i).dead) {
                lightnings.remove(i);
            }
        }
    }

     public void ResetLightnings () {
        firstOccur = true;
    }

}
class Tower {
  Stack<Block> Tower = new Stack<>();

  // DEFAULT Constructor
  Tower() {};

   public void drawTower() {
    for (int i = 0; i < Tower.size(); i++) {
      if (Tower.get(i).isTextureMode) {
        Tower.get(i).drawTextureBlock();
      }
      else {
        Tower.get(i).drawColorBlock();
      }
    }

    return;
  }

   public void pushBlock(Block block) {
    if (Tower.isEmpty()) {
      Tower.push(block);
    }
    else {
      block.y = Tower.peek().y - Tower.peek().blockHeight;
      Tower.push(block);
    }

    return;
  }

   public Block popBlock() {
    return Tower.pop();
  }
}
PImage chopstick;
float t = 0;
 public void Chopstick(Block block) {
  Block block_ = block;
  t+=0.02f;
  float tx;
  float ty;
  if (t<1) {
    tx = lerp(width, block_.x*14/11, t);
    ty = lerp(0, block_.y - block_.size*block.blockHeight*5/2, t);
    pushMatrix();
    imageMode(CENTER);
    block_.createBlock();
    image(chopstick, tx, ty, block_.size*block_.blockHeight*5, block_.size*block_.blockHeight*5);
    popMatrix();
  } else if (block_.y >0) {
    block_.y -=5;
    pushMatrix();
    imageMode(CENTER);
    block_.createBlock();
    image(chopstick,block_.x*14/11,block_.y - block_.size*block.blockHeight*5/2,block_.size*block_.blockHeight*5, block_.size*block_.blockHeight*5);
    popMatrix();
  } else {
    chopstickAct = false;
    t = 0;
  }
}
float punchTimeChecker = 0;
PImage windowBreak;
PImage punchM;
 public void Punching(Block block) {
  Block block_ = block;
  punchTimeChecker +=0.1f;
  if (punchTimeChecker <1) {
    pushMatrix();
    imageMode(CENTER);
    image(windowBreak, width/2, height/2, width, height);
    image(punchM, block_.x, height*3/4, width/3, height/2);
    popMatrix();
  } //else if (punchTimeChecker >=1) background(200);
  if (block_.size >0)
    block_.size -=0.3f;
  block_.createBlock();
  if(block_.size <=0) punchAct = false; //block go to outside of window finish the function
}
PImage balloon;
 public void beforeWind(Block block) { // if balloon function start balloon follow mouse
  pushMatrix();
  imageMode(CENTER);
  image(balloon, mouseX, mouseY, block.size*block.blockHeight*2, block.size*block.blockHeight*2);
  popMatrix();
}

 public void wind(Block block) { // balloon attached and fly away
  Block block_ = block;
  block_.x += 3;
  block_.y -=3;
  block_.createBlock();
  pushMatrix();
  imageMode(CENTER);
  image(balloon, block_.x, block_.y -block.size*block.blockHeight*2, block.size*block.blockHeight*2, block.size*block.blockHeight*2);
  popMatrix();
  if (block_.y<0)balloonAttached = false; // finish the function
}


  public void settings() { size(1000, 1000, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Intergrated" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
